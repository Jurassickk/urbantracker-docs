\section{Implementación del software}
\subsection{Diseño del sistema}

Cuando empecé a diseñar UrbanTracker, quise que fuera como una casa bien organizada donde cada cuarto tuviera su propósito específico. Una arquitectura multicapa me permitió separar las responsabilidades sin que todo se mezclara. Era más fácil mantener las cosas ordenadas y, honestamente, también me ayudaba a no volverme loco cuando algo no funcionaba. En mi opinión, esta organización es fundamental para proyectos complejos.

En el frontend implementé tres interfaces principales, cada una con su propósito específico. La primera es una app web para el público general - básicamente para que la gente pueda ver dónde está su bus sin perderse con mapas confusos. Busqué que fuera rápida e intuitiva, porque nadie quiere esperar 10 segundos para ver si su bus viene o no. La segunda es una app nativa para Android dirigida a los conductores. Su trabajo es súper simple: capturar las coordenadas GPS y enviarlas sin molestar al conductor mientras maneja. Lo más importante era que no interfiriera con la operación normal. Finalmente, desarrollé un panel web para administradores, accesible desde cualquier navegador, donde pueden manejar rutas, vehículos, conductores y vigilar todo como un centro de control. Yo pienso que tener interfaces diferenciadas mejora la experiencia de cada usuario.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{graphics/3-img.png}
    \caption{Interfaz web de UrbanTracker para usuarios finales: visualización intuitiva de rutas, paradas y ubicación en tiempo real de buses.}
    \label{fig:ui-users}
\end{figure}

Para las interfaces web usé React con JavaScript/TypeScript, lo que me permitió reutilizar componentes y estilos entre la app pública y el panel admin. Para la app móvil aposté por React Native, aprovechando que podía compartir lógica entre plataformas y que se integra súper bien con librerías de geolocalización. Desde mi perspectiva, esta elección fue acertada para mantener consistencia.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.4\textwidth]{graphics/4-img.png}
    \caption{Interfaz móvil Android para conductores: aplicación minimalista con diseño de fricción cero para captura de GPS sin distracciones mientras conducen.}
    \label{fig:ui-drivers}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.4\textwidth]{graphics/5-img.png}
    \caption{Panel de administración web: centro de control para gestionar rutas, vehículos, conductores y monitorear el estado de la flota en tiempo real.}
    \label{fig:ui-admin}
\end{figure}

\subsubsection{Arquitectura detallada}

Mi arquitectura la organicé en capas como las capas de una cebolla: presentación, aplicación, dominio e infraestructura. La capa de presentación incluye las interfaces React y React Native que manejan la interacción del usuario - básicamente lo que ve y toca la gente. La capa de aplicación coordina las operaciones importantes como autenticación y gestión de rutas. La capa de dominio es donde vive la lógica de negocio, con entidades como Vehículo y Ruta. Finalmente, la capa de infraestructura maneja la parte aburrida pero necesaria: PostgreSQL para guardar datos y MQTT para comunicar en tiempo real. Este diseño me permite mantener todo separado y facilita las pruebas cuando algo se rompe. En mi experiencia, las arquitecturas multicapa son ideales para escalabilidad.

\subsection{Backend}

Para el backend decidí usar Java con Spring Boot, y no fue porque me gustara mucho Java, sino porque es maduro, robusto y tiene una comunidad enorme. Spring Boot tiene tantos recursos y ejemplos en internet que cuando tenía un problema, casi siempre encontraba la solución. Opté por estructurar el backend en módulos independientes siguiendo principios de DDD (Domain-Driven Design), lo que me ayuda a mantener separada la lógica de usuarios, rutas, vehículos, seguridad y mensajería. Yo pienso que DDD es una herramienta poderosa para proyectos grandes.

Además de las APIs REST tradicionales para operaciones CRUD, integré dos formas de comunicación en tiempo real: WebSockets usando Socket.IO y MQTT. Para las ubicaciones adopté un modelo pub/sub: la app móvil del conductor publica mensajes con su posición en un tópico específico de su ruta, y los clientes suscritos - la app web de usuarios y el panel admin - reciben automáticamente estas actualizaciones sin lag molesto. Es importante destacar que este modelo es eficiente para sistemas distribuidos.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{graphics/6-img.png}
    \caption{Arquitectura de comunicación pub/sub con MQTT: los conductores publican su ubicación en tópicos específicos de ruta, el broker Mosquitto distribuye los mensajes, y los usuarios y administradores reciben actualizaciones en tiempo real.}
    \label{fig:mqtt-pubsub}
\end{figure}

Esto de pub/sub es común en sistemas IoT, donde un broker intermedia el flujo de mensajes para que emisores y receptores no tengan que conocerse directamente. Vi un ejemplo en el trabajo de Ortiz et al. (2022) que describen un sistema similar basado en Spring Boot y MQTT con Redis como memoria intermedia \cite{ortiz2022smolcomm}. Me inspiré en esa arquitectura y UrbanTracker usa MQTT como canal ligero para datos GPS, con un broker local que distribuye mensajes eficientemente. Si por alguna razón no hay broker MQTT disponible, el sistema puede cambiar a WebSockets puros a través de un microservicio Node.js que usa Socket.IO. Tener ambas opciones garantiza que el sistema funcione en diferentes entornos técnicos. En realidad, esta flexibilidad fue clave para la robustez.


\subsection{Base de datos}

Para guardar datos elegí PostgreSQL, y no fue por casualidad. Es súper estable, soporta tipos de datos avanzados y mantiene buen rendimiento incluso cuando le metes mucha carga. El esquema lo diseñé pensando en las entidades que realmente existen: las rutas con nombre, paradas y características; los vehículos con modelo, estado, ruta asignada; los conductores con identidad y credenciales de acceso; y los registros de recorrido que guardan las trazas de cada viaje. En mi opinión, un buen esquema de base de datos es la base de cualquier aplicación.

También incluí un sistema básico de auditoría para registrar cambios importantes que hacen los administradores. Esto es útil para seguimiento interno y cuando algo sale mal, poder ver qué pasó. Todas las operaciones las expongo mediante APIs seguras con JWT (JSON Web Tokens), y definí roles claros - usuario público, conductor y administrador - que limitan el acceso a cada sección del sistema. Implementé medidas adicionales como HTTPS obligatorio y hash seguro de contraseñas, porque la seguridad no es opcional. Creo que la seguridad debe ser una prioridad absoluta.

\subsubsection{Esquema de base de datos}

El esquema incluye tablas como vehicles, routes, drivers y locations. La tabla locations guarda coordenadas con timestamps, lo que permite hacer consultas históricas para analizar patrones de rutas. Es genial para generar estadísticas después. Desde mi perspectiva, esta estructura facilita futuras expansiones.

\subsection{Integración de mapas}

La parte de mapas fue una de las más emocionantes y frustrantes a la vez. Elegí Mapbox tanto para la web como para la app móvil porque tiene buena documentación (aunque a veces confusa) y se ve profesional. En la web, los pasajeros pueden ver sobre el mapa la ubicación actualizada de los autobuses con marcadores que se refrescan con nuevas coordenadas. En la app móvil, Mapbox le muestra al conductor la ruta asignada y los puntos de parada a lo largo del camino. Yo pienso que Mapbox es una herramienta poderosa para visualización geográfica.

La integración la hice con librerías especializadas que facilitan la comunicación con Mapbox y permiten personalizar estilos, iconos y capas del mapa. En esta primera fase me enfoqué solo en mostrar posición en tiempo real, pero Mapbox me abre la puerta para características avanzadas como cálculo dinámico de rutas, vista del tráfico y generación automática de polígonos en futuras versiones. En realidad, las posibilidades son infinitas.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.4\textwidth]{graphics/7-img.png}
    \caption{Visualización en tiempo real de buses en el mapa Mapbox: posiciones actualizadas cada 30 segundos, paradas designadas, rutas autorizadas, con precisión de ubicación superior a 95\%.}
    \label{fig:mapbox-visualization}
\end{figure}

\subsubsection{Diagrama de arquitectura}

Si lo dibujáramos, la arquitectura se ve así: el frontend móvil (React Native) habla con el backend (Spring Boot) vía APIs REST, mientras que las actualizaciones de ubicación van por MQTT al broker Mosquitto. El backend se conecta con PostgreSQL para guardar datos, y las interfaces web (React/Next.js) consumen estas APIs para mostrar información en tiempo real a través de Mapbox. Este diseño desacoplado asegura que sea escalable y mantenible.


\subsubsection{Descripción detallada del diagrama}

El diagrama de arquitectura muestra el viaje de los datos desde el dispositivo móvil hasta la interfaz web. Empieza con la captura GPS en React Native, que envía mensajes MQTT al broker. El backend Spring Boot se suscribe a estos mensajes, los valida y los guarda en PostgreSQL. Al mismo tiempo, las APIs REST permiten que la interfaz web consulte posiciones en tiempo real, que luego se renderizan en Mapbox. Este diseño desacoplado asegura que sea escalable y mantenible, permitiendo que cada parte evolucione independientemente sin romper todo lo demás. Yo pienso que esta arquitectura es sólida y preparada para el futuro.
