\section{Implementación del software}
\subsection{Diseño del sistema}
UrbanTracker lo concebimos desde el inicio con una arquitectura multicapa que separa claramente las responsabilidades entre los distintos componentes del sistema. La lógica de negocio, la gestión de datos y las interfaces de usuario las estructuramos de forma independiente para facilitar el mantenimiento, la evolución futura y el trabajo colaborativo dentro del equipo de desarrollo. En el frontend, implementamos tres interfaces principales, cada una adaptada a un rol distinto. La primera es una aplicación web destinada al público general, donde los pasajeros pueden consultar las rutas activas y visualizar en tiempo real la ubicación de los autobuses. Buscamos que esta interfaz fuera intuitiva, rápida y compatible con la mayoría de navegadores modernos. La segunda es una aplicación móvil nativa construida específicamente para Android, pensada para los conductores. Su función principal es capturar las coordenadas GPS del dispositivo y transmitirlas de forma continua al sistema, sin interrumpir la operación normal del conductor. Finalmente, desarrollamos una interfaz web para administradores, accesible desde cualquier navegador, que permite gestionar rutas, vehículos y conductores, así como supervisar el estado de la flota mediante un panel de control centralizado. Tanto la aplicación pública como el panel administrativo las implementamos usando React (JavaScript/TypeScript), lo que permitió compartir componentes, estilos y lógica de estado. Por su parte, la app móvil la construimos con React Native, aprovechando su capacidad multiplataforma y su buena integración con librerías de geolocalización.

\subsubsection{Arquitectura detallada}
La arquitectura se basa en un patrón de capas: presentación, aplicación, dominio y infraestructura. La capa de presentación incluye las interfaces React y React Native, que manejan la interacción del usuario. La capa de aplicación coordina las operaciones, como la autenticación y la gestión de rutas. La capa de dominio contiene la lógica de negocio, con entidades como Vehículo y Ruta. Finalmente, la capa de infraestructura maneja la persistencia en PostgreSQL y la comunicación MQTT. Este diseño permite una separación clara, facilitando pruebas y escalabilidad.

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{graphics/5-img.png}
\caption{Arquitectura del sistema UrbanTracker: componentes frontend, backend, base de datos y protocolos de comunicación}
\label{fig:arquitectura-sistema}
\end{figure}

\subsection{Backend}
El backend lo desarrollamos en \textbf{Java} utilizando el framework \textbf{Spring Boot}, el cual seleccionamos por su madurez, robustez y su amplia compatibilidad con servicios REST y patrones arquitectónicos modulares. Optamos por estructurar el backend en módulos independientes siguiendo principios básicos de DDD (Domain-Driven Design), lo que facilita mantener separada la lógica correspondiente a usuarios, rutas, vehículos, seguridad y mensajería. Además de los servicios RESTful tradicionales usados para las operaciones CRUD, integramos mecanismos de comunicación en tiempo real mediante WebSockets (a través de Socket.IO) y mediante el protocolo MQTT. Para el envío de las ubicaciones adoptamos un modelo de publicación/suscripción (pub/sub): la aplicación móvil del conductor publica mensajes con su posición en un tópico específico asociado a su ruta o vehículo, y los clientes suscritos —la aplicación web de usuarios y el panel administrativo— reciben automáticamente estas actualizaciones con mínima latencia. Este enfoque es común en sistemas IoT, donde un broker se encarga de intermediar el flujo de mensajes para desacoplar los emisores de los receptores. Un ejemplo similar lo encontramos en el trabajo de Ortiz et al. (2022), quienes describen un sistema de comunicaciones autónomo basado en Spring Boot y MQTT (Mosquitto), con Redis como memoria intermedia para manejar grandes volúmenes de mensajes en tiempo real \cite{ortiz2022smolcomm}. Inspirándonos en este tipo de arquitecturas, UrbanTracker emplea MQTT como canal ligero para transmitir datos GPS, usando un broker local que distribuye los mensajes de forma eficiente. En escenarios donde no se disponga de un broker MQTT, el sistema puede alternar hacia WebSockets puros integrados mediante un microservicio en Node.js que utiliza Socket.IO para canalizar las posiciones hacia los usuarios. La coexistencia de ambas opciones garantiza adaptabilidad a diferentes entornos técnicos.

\subsubsection{Código de ejemplo}
A continuación, se muestra un fragmento de código en Java para el servicio de geolocalización en Spring Boot:

\begin{lstlisting}[language=Java]
@Service
public class LocationService {

    @Autowired
    private LocationRepository locationRepository;

    @Autowired
    private MqttClient mqttClient;

    public void processLocationUpdate(String topic, String message) {
        // Parsear el mensaje JSON
        LocationUpdate update = parseJson(message);
        // Validar y guardar en BD
        locationRepository.save(update);
        // Publicar a suscriptores
        mqttClient.publish("location/updates", update.toJson());
    }
}
\end{lstlisting}

Este servicio recibe actualizaciones MQTT, las procesa y las retransmite a los clientes conectados.

\subsection{Base de datos}
Para la persistencia de datos elegimos PostgreSQL, un sistema de gestión de bases de datos SQL reconocido por su estabilidad, soporte para tipos avanzados y rendimiento consistente incluso con cargas elevadas. El esquema de datos lo diseñamos para reflejar las diferentes entidades involucradas: las rutas, con su nombre, paradas y características; los vehículos, que incluyen información como modelo, estado o ruta asignada; los conductores, con su identidad y credenciales de acceso; y los registros de recorrido, que almacenan las trazas de movimiento asociadas a cada viaje. Además, incorporamos un sistema básico de auditoría para registrar cambios relevantes realizados por administradores, lo cual es útil para seguimiento interno y verificación de incidentes. Todas las operaciones las exponemos mediante una API segura controlada con JWT (JSON Web Tokens), y los roles definidos —usuario público, conductor y administrador— permiten limitar el acceso a cada sección del sistema, respetando las políticas de seguridad planteadas en los requisitos. Implementamos también medidas complementarias como el uso obligatorio de HTTPS y el hash seguro de contraseñas.

\subsubsection{Esquema de base de datos}
El esquema incluye tablas como \texttt{vehicles}, \texttt{routes}, \texttt{drivers} y \texttt{locations}. La tabla \texttt{locations} almacena coordenadas con timestamps, permitiendo consultas históricas para análisis de rutas.

\subsection{Integración de mapas}
La visualización geográfica es uno de los elementos centrales de UrbanTracker. Para ello, integramos la API de Mapbox, tanto en la plataforma web dirigida a los usuarios como en la aplicación móvil para conductores. En el caso de la web, los pasajeros pueden observar sobre el mapa la ubicación actualizada de los autobuses mediante marcadores que se refrescan conforme llegan nuevas coordenadas. En la app móvil, Mapbox se utiliza principalmente para mostrar al conductor la ruta asignada y, eventualmente, permitir la visualización de puntos de parada distribuidos a lo largo del trayecto. La integración la realizamos mediante librerías especializadas que facilitan la comunicación con Mapbox y permiten personalizar estilos, iconos y capas del mapa. Si bien en esta primera fase la visualización se centra en representar la posición en tiempo real, la elección de Mapbox abre la posibilidad de incorporar características más avanzadas como cálculo dinámico de rutas, vista del tráfico y generación automática de polígonos, funciones que podríamos explorar en futuras versiones del sistema.

\subsubsection{Diagrama de arquitectura}
La arquitectura se puede representar conceptualmente como sigue: el frontend móvil (React Native) se comunica con el backend (Spring Boot) vía APIs REST, mientras que las actualizaciones de ubicación se transmiten mediante MQTT al broker Mosquitto. El backend interactúa con PostgreSQL para persistencia de datos, y las interfaces web (React/Next.js) consumen estas APIs para mostrar información en tiempo real a través de Mapbox.

\subsubsection{Código adicional de ejemplo}
A continuación, se muestra un fragmento del código en React Native para la captura de ubicación GPS:

\begin{lstlisting}[language=Java]
import { useEffect, useState } from 'react';
import { PermissionsAndroid, Platform } from 'react-native';
import Geolocation from 'react-native-geolocation-service';

const LocationTracker = () => {
  const [location, setLocation] = useState(null);

  useEffect(() => {
    const requestLocationPermission = async () => {
      if (Platform.OS === 'android') {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION
        );
        if (granted === PermissionsAndroid.RESULTS.GRANTED) {
          startLocationTracking();
        }
      } else {
        startLocationTracking();
      }
    };

    const startLocationTracking = () => {
      Geolocation.watchPosition(
        (position) => {
          setLocation(position.coords);
          // Enviar a MQTT
          publishLocation(position.coords);
        },
        (error) => console.log(error),
        { enableHighAccuracy: true, distanceFilter: 10 }
      );
    };

    requestLocationPermission();
  }, []);

  return (
    <View>
      {location && <Text>Lat: {location.latitude}, Lon: {location.longitude}</Text>}
    </View>
  );
};
\end{lstlisting}

Este componente solicita permisos de ubicación, inicia el seguimiento GPS y publica las coordenadas al broker MQTT cada vez que el dispositivo se mueve más de 10 metros.

\subsubsection{Descripción detallada del diagrama}
El diagrama de arquitectura ilustra el flujo de datos desde el dispositivo móvil hasta la interfaz web. Comienza con la captura GPS en React Native, que envía mensajes MQTT al broker. El backend Spring Boot suscribe a estos mensajes, valida y almacena en PostgreSQL. Simultáneamente, las APIs REST permiten a la interfaz web consultar posiciones en tiempo real, renderizadas en Mapbox. Este diseño desacoplado asegura escalabilidad y mantenibilidad, permitiendo que cada componente evolucione independientemente.