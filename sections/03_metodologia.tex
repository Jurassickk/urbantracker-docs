\section{Metodología de investigación aplicada}

Al principio, la verdad es que no tenía ni idea de por dónde empezar. Era como querer armar una casa sin saber si primero pones los cimientos o el techo. Recuerdo que me pasé semanas investigando metodologías de desarrollo de software, leyendo libros sobre ágil, y viendo tutoriales en YouTube. Me sentía abrumado con tantas opciones: ¿usar Scrum? ¿Kanban? ¿XP? ¿O simplemente improvisar?

Después de investigar mucho, decidí que lo mejor era ir paso a paso, con enfoque iterativo para aprender en el camino. "No construyas todo de golpe", me dije. "Empieza con algo simple que funcione, y luego agrega capas".

Así que la primera versión de UrbanTracker era supersencilla - solo mostraba posición de un bus en mapa. Sin autenticación, sin rutas múltiples, sin panel admin. Solo mapa con marcador moviéndose en vivo. Pero eso me ayudó a ver qué era realmente importante y qué era opcional.

Esa versión inicial me tomó justo 2 semanas de desarrollo intensivo. Aprendí a integrar Mapbox con React, configurar servidor básico con Node.js, y manejar conexiones WebSocket para updates en tiempo real. Fue frustrante al inicio - problemas con CORS, tokens de Mapbox, sincronización entre frontend y backend. Pero cada bug resuelto era victoria que me motivaba.

Una vez que funcionó lo básico, lo probé con amigos y familia. Sus comentarios fueron puros diamantes: "¿Por qué solo un bus? ¿Y si quiero ver rutas múltiples?" "¿Cómo sé cuál es mi parada cercana?" "¿Puedo ver cuánto falta para que llegue?"

Esos feedbacks me dieron rumbo claro para iteraciones siguientes. Agregué soporte para buses múltiples, rutas fijas, interfaz más intuitiva. Cada ciclo tomó 1-2 semanas, y terminaba probando con usuarios reales para más input.

Para arquitectura, al principio quise microservicios porque sonaban modernos y pro. Pero pensándolo bien, era como comprar Ferrari para ir a esquina. Monolito modular era perfecto para empezar - organizaba código en módulos separados, sin complejidad de múltiples servicios desde día uno.

Aquí decisiones se volvieron personales. Para web, quería algo pro pero no complicado. Después de ver opciones, React con Next.js me atrajo porque tenía experiencia en JS, y renderizado rápido era clave - nadie espera 5 segundos para ver mapa.

Para app móvil, pensé en nativo para Android, pero luego vi que con React Native podía hacer misma app para iOS sin reescribir. Me enfoqué en Android porque, como sabemos, en transporte colombiano (y muchos latinoamericanos) Android manda.

Una de las mejores decisiones fue usar patrones iguales en web y móvil. Cuando aprendía algo nuevo en una, lo aplicaba en otra. Por ejemplo, useEffect en React Native para updates de ubicación era igual que en React web, transición supersuave.

La primera barrera fue seguridad. Al inicio pensé: "Bueno, ¿necesitamos auth? Es solo tracker de buses". Pero amigos en IT me hicieron ver que no podía dejar manipular datos cualquiera. Sería dar llaves del sistema de transporte a todos.

Así que me metí en Spring Security y JWT. Al principio confusísimo - tokens, refresh, scopes... Después de tutoriales y errores, funcionó. Lo chévere fue ver que APIs REST servían igual para web y móvil. Como lenguaje común entre partes.

Mi API favorita era obtener rutas activas - simple en teoría, pero con casos edge: ¿si no hay rutas? ¿error en BD? Cada API era rompecabezas pequeño.

Aquí se puso interesante (y frustrante). Geolocalización suena fácil hasta implementarla real.

Primero aprendí que no todos buses tienen GPS integrado - algunos viejos dependen de GPS del teléfono conductor. Obligó lógica automática para detectar fuente GPS.

MQTT fue desafío aparte. Pensé era enviar mensajes normales, pero era "topics" y "subscriptions". Analogía: cada ruta como canal YouTube, buses publican posiciones en canal propio. Broker (Mosquitto) asegura solo suscriptores vean.

Mayor dolor de cabeza: validación. ¿Cómo saber coordenada GPS válida? ¿Si conductor apaga app? ¿GPS loco mandando imposibles? Creé sistema guardián - verificaba cada coordenada antes guardar.

PostgreSQL elección no arrepentida. Pensé SQLite simple, pero contento con más datos. Separar tablas por dominio (rutas, vehículos, ubicaciones) mantuvo código ordenado, consultas rápidas.

Interfaces web diseñadas para experiencia clara usuarios finales y admins. Visor mapas -con Mapbox- consume coordenadas backend, muestra posición reciente vehículos servicio. Para admins panel crear rutas, registrar vehículos, asignar conductores, monitorear estado flota. Panel como centro control, facilita gestión diaria. En usabilidad aplicamos principios user-centered, iterando con feedback inicial para interfaces intuitivas accesibles.

Para garantizar reproducibilidad y facilitar pruebas, configuramos entorno local con Docker Compose. Incluye PostgreSQL y Mosquitto, permite levantar arquitectura sin installs manuales. Variables entorno estandarizadas dieron consistencia entre ambientes. Archivo docker-compose.yml define volúmenes persistentes BD, asegurando datos prueba entre reinicios.

Durante proceso hicimos pruebas unitarias parciales servicios sensibles, integración básica con datos simulados verificar estabilidad comunicación app móvil, backend, web. Priorización siguió specs funcionales, enfocándonos visualización rutas y updates real. No integramos sensores externos ni plataformas smart cities esta fase, sistema opera autónomo con infra móvil disponible. Metodología iterativa permitió identificar resolver problemas tempranos, como conflictos serialización JSON, asegurando módulos cumplieran criterios aceptación antes integración.

Además incorporamos control versiones con Git, ramas features específicas, facilitando collab y resolución conflictos. Docs actualizadas con READMEs detallados, diagramas UML simples. Enfoque mejoró calidad código, preparó expansiones como predictivas con ML.

Enfoque iterativo permitió identificar resolver problemas tempranos, como integración libs mapas React Native, requirió ajustes permisos location y manejo estados async. Iteraciones aseguraron producto final funcional, eficiente, mantenible.