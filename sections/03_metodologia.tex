\section{Metodología de investigación aplicada}
El desarrollo de UrbanTracker siguió un enfoque iterativo incremental, lo cual permitió avanzar de manera progresiva, validando cada componente a medida que se iba construyendo. Esta decisión metodológica se adoptó porque el sistema involucra diversos módulos que dependen entre sí, y era necesario verificar su funcionamiento individual antes de integrarlos. Desde el inicio se definió una arquitectura basada en un monolito modular construido con Spring Boot y principios sencillos de Domain-Driven Design (DDD). Esta estructura permitió dividir el proyecto en diferentes dominios —como autenticación, administración de rutas, gestión de conductores o almacenamiento de datos de ubicación— sin perder la posibilidad de evolucionar posteriormente hacia una arquitectura de microservicios si las necesidades de escalabilidad así lo requieren.

En cuanto a las interfaces de usuario, el frontend web se desarrolló empleando React con Next.js, principalmente por su capacidad para manejar renderizado eficiente y facilitar la creación de vistas responsivas. Paralelamente, la aplicación móvil se implementó utilizando React Native, enfocada inicialmente en dispositivos Android, tomando en cuenta que este sistema operativo es el más común entre conductores de transporte urbano. La elección de estas tecnologías permitió mantener coherencia en el desarrollo, ya que comparten el lenguaje JavaScript y patrones similares de construcción de componentes. Para ilustrar, en React Native se utilizó el hook useEffect para manejar la suscripción a actualizaciones de ubicación, asegurando que el componente se actualice solo cuando sea necesario y optimizando el rendimiento en dispositivos móviles.

Durante las primeras etapas del desarrollo, se priorizó la implementación del módulo de autenticación, utilizando Spring Security junto con JWT para asegurar que el acceso al sistema se realizara de manera controlada. Una vez establecida la seguridad básica, se procedió a construir las distintas APIs REST necesarias para gestionar usuarios, rutas, vehículos y conductores. Estas APIs son consumidas tanto por la plataforma web como por la aplicación móvil, garantizando una comunicación uniforme entre los distintos clientes y el backend. Por instancia, la API para obtener rutas activas sigue el patrón RESTful estándar, devolviendo datos en formato JSON con códigos de estado apropiados, lo que facilita la integración con clientes diversos.

Paralelamente, se habilitó la funcionalidad esencial de geolocalización en la aplicación móvil. Esta obtiene la ubicación GPS del dispositivo del conductor y publica las coordenadas en intervalos regulares hacia un broker MQTT —en este caso Mosquitto— encargado de distribuir esos datos al backend. La lógica contempla escenarios en los que el vehículo no cuente con un módulo GPS integrado, utilizando entonces exclusivamente el GPS del teléfono móvil. En el servidor, los servicios desarrollados en Spring Boot se suscriben a tópicos MQTT específicos para cada ruta, lo que permite recibir únicamente las actualizaciones relevantes y procesarlas de forma ordenada. Cada mensaje recibido pasa por un proceso de validación antes de almacenarse en PostgreSQL. La base de datos se organizó siguiendo el modelo modular del propio backend, con esquemas separados según el dominio al que pertenece la información. Finalmente, la última posición registrada para cada vehículo se expone mediante servicios REST, asegurando que las interfaces de usuario puedan consultarla en cualquier momento. Esta separación modular no solo mejora la mantenibilidad, sino que también permite pruebas independientes, como simular mensajes MQTT para verificar el procesamiento de datos.

Las interfaces web fueron diseñadas para ofrecer una experiencia clara tanto a los usuarios finales como a los administradores. El visor de mapas —construido usando Mapbox— consume las coordenadas almacenadas en el backend y muestra la posición más reciente de cada vehículo en servicio. Para los administradores se desarrolló un panel desde el cual pueden crear rutas, registrar vehículos, asignar conductores y monitorear el estado operativo de la flota. Este panel funciona como un punto centralizado de control que facilita la gestión diaria del sistema de transporte. En términos de usabilidad, se aplicaron principios de diseño centrado en el usuario, realizando iteraciones basadas en retroalimentación inicial para asegurar que las interfaces fueran intuitivas y accesibles.

Con el fin de garantizar reproducibilidad y facilitar las pruebas, se configuró un entorno local utilizando Docker Compose. Este entorno incluye servicios como PostgreSQL y Mosquitto, permitiendo que cualquier integrante del equipo pueda levantar la arquitectura completa sin necesidad de instalaciones manuales. El uso de variables de entorno estandarizadas contribuyó a mantener consistencia entre ambientes de desarrollo. Por ejemplo, el archivo docker-compose.yml define volúmenes persistentes para la base de datos, asegurando que los datos de prueba se mantengan entre reinicios.

A lo largo del proceso se realizaron pruebas unitarias parciales sobre los servicios más sensibles, así como pruebas de integración básicas utilizando datos simulados para verificar la estabilidad de la comunicación entre la aplicación móvil, el backend y la interfaz web. La priorización del desarrollo se mantuvo alineada con las especificaciones funcionales establecidas desde el inicio, centrándose primero en características esenciales como la visualización de rutas y la actualización de posiciones en tiempo real. No fue necesario integrar sensores externos ni plataformas de ciudades inteligentes en esta fase, ya que el sistema está diseñado para operar de forma autónoma con la infraestructura móvil disponible actualmente. Esta metodología iterativa permitió identificar y resolver problemas tempranos, como conflictos en la serialización de datos JSON, y aseguró que cada módulo cumpliera con los criterios de aceptación antes de proceder a la integración.
Además, se incorporaron prácticas de control de versiones utilizando Git, con ramas dedicadas para características específicas, lo que facilitó el trabajo colaborativo y la resolución de conflictos. La documentación se mantuvo actualizada mediante READMEs detallados y diagramas UML simples para ilustrar la arquitectura. Esta aproximación no solo mejoró la calidad del código, sino que también preparó el terreno para futuras expansiones, como la adición de funcionalidades de predicción basadas en machine learning.
Además, se incorporaron prácticas de control de versiones utilizando Git, con ramas dedicadas para características específicas, lo que facilitó el trabajo colaborativo y la resolución de conflictos. La documentación se mantuvo actualizada mediante READMEs detallados y diagramas UML simples para ilustrar la arquitectura. Esta aproximación no solo mejoró la calidad del código, sino que también preparó el terreno para futuras expansiones, como la adición de funcionalidades de predicción basadas en machine learning.

El enfoque iterativo permitió identificar y resolver problemas tempranos, como la integración de librerías de mapas en React Native, que requirió ajustes en permisos de localización y manejo de estados asíncronos. Estas iteraciones aseguraron que el producto final fuera no solo funcional, sino también eficiente y fácil de mantener.